package resume

import (
	"Q-Solver/pkg/config"
	"Q-Solver/pkg/llm"
	"Q-Solver/pkg/logger"
	"context"
	"encoding/base64"
	"fmt"
	"os"

	"github.com/wailsapp/wails/v2/pkg/runtime"
)

type Service struct {
	config       config.Config // 存储配置副本
	resumeBase64 string        // 缓存的简历 Base64
}

func NewService(cfg config.Config, cm *config.ConfigManager) *Service {
	s := &Service{
		config: cfg,
	}
	// 订阅配置变更，同步配置
	cm.Subscribe(func(NewConfig config.Config, oldConfig config.Config) {
		s.config = NewConfig
		// 如果简历路径变了，清空缓存
		if NewConfig.ResumePath != oldConfig.ResumePath {
			s.resumeBase64 = ""
		}
	})
	return s
}

// SelectResume 打开文件对话框选择简历，并返回路径
func (s *Service) SelectResume(ctx context.Context) string {
	selection, err := runtime.OpenFileDialog(ctx, runtime.OpenDialogOptions{
		Title: "选择简历 (PDF)",
		Filters: []runtime.FileFilter{
			{
				DisplayName: "PDF Files",
				Pattern:     "*.pdf",
			},
		},
	})

	if err != nil {
		logger.Printf("选择文件失败: %v\n", err)
		return ""
	}

	if selection == "" {
		return "" // 用户取消
	}

	// 不再直接修改配置，由调用者处理
	return selection
}

// ClearResume 清除简历缓存
func (s *Service) ClearResume() {
	s.resumeBase64 = ""
	logger.Println("简历缓存已清除")
}

// GetResumeBase64 读取简历并转换为 Base64
func (s *Service) GetResumeBase64() (string, error) {
	// 读一下缓存
	if len(s.resumeBase64) > 0 {
		logger.Println("使用缓存的简历 Base64")
		return s.resumeBase64, nil
	}
	if s.config.ResumePath == "" {
		return "", nil
	}

	// 检查文件大小
	fileInfo, err := os.Stat(s.config.ResumePath)
	if err != nil {
		return "", err
	}

	// 限制 5MB
	if fileInfo.Size() > 5*1024*1024 {
		return "", fmt.Errorf("简历文件大小超过 5MB 限制")
	}

	// 读取文件内容
	content, err := os.ReadFile(s.config.ResumePath)
	if err != nil {
		return "", err
	}

	// 转换为 Base64 并缓存
	encoded := base64.StdEncoding.EncodeToString(content)
	s.resumeBase64 = encoded
	return encoded, nil
}

// ParseResume 解析简历为 Markdown
func (s *Service) ParseResume(ctx context.Context, provider llm.Provider) (string, error) {
	// 1. Read Resume
	resumeBase64, err := s.GetResumeBase64()
	if err != nil {
		return "", fmt.Errorf("读取简历失败: %v", err)
	}
	if resumeBase64 == "" {
		return "", fmt.Errorf("未选择简历文件")
	}
	logger.Println("开始解析简历为 Markdown...")

	// 2. 构建解析简历的消息
	messages := []llm.Message{
		llm.NewUserMessage(resumeParsePrompt),
		llm.NewMultiPartMessage(llm.RoleUser, []llm.ContentPart{
			llm.PDFPart(resumeBase64),
		}),
	}

	// 3. 调用 LLM Provider
	result, err := provider.GenerateContentStream(ctx, messages, nil)
	if err != nil {
		return "", err
	}
	return result.Content, nil
}

// resumeParsePrompt 简历解析 Prompt
const resumeParsePrompt = `# Role 你是一个**通用型简历重构与解析引擎**。你的任务是将输入的简历内容（无论行业是互联网、销售、财务还是行政），提取并严格按照我指定的【通用美观模板】转换为 Raw Markdown 格式。 

# 🚨 STRICT OUTPUT PROTOCOL (绝对输出协议) 
1. **纯文本输出**：输出**必须**是原始 Markdown 文本。**严禁**使用 markdown 代码块包裹。 
2. **内容自适应**：根据候选人的行业调整关键词。例如： 
   - 对于程序员，提取"技术栈"； 
   - 对于销售，提取"关键客户/业绩"； 
   - 对于行政，提取"办公技能/组织能力"。 
3. **空值处理**：如果简历中缺少某项信息（如个人网站），直接不显示该行。 
4. **排版强制**：严格保留模板中的 Emoji 图标和引用块格式。 

# 💅 Universal Visual Template (通用美观模板) 

# {{姓名}} 
> 💼 **{{求职意向/当前职位}}** 
> 
> 📱 {{电话}}  |  📧 {{邮箱}}  |  📍 {{所在城市}} 
> 🔗 [作品集/LinkedIn/个人主页]({{链接地址}}) *(如有才显示)* 

--- 

## ⚡ 专业技能 
*(请根据职业属性归类，以下仅为示例，请灵活调整 Key)* 
- **核心竞争力**: {{如：大客户销售 / 财务审计 / Java开发 / 团队管理}} 
- **软件/工具**: {{如：SAP / Excel高级 / Photoshop / Docker}} 
- **证书/语言**: {{如：CPA注册会计师 / 英语六级 / PMP}} 

## 🏢 工作经历 
### **{{公司名称}}** 
**{{职位名称}}** | *{{开始时间}} - {{结束时间}}* 
> {{一句话概括核心职责。如：负责大区销售团队管理，或：负责公司年度审计工作。}} 
- 🔸 **{{核心业绩/产出1}}**: {{详细描述，尽可能包含数据，如：销售额增长 20% / 节省成本 50万}} 
- 🔸 **{{核心业绩/产出2}}**: {{详细描述}} 
- 🔸 **{{核心业绩/产出3}}**: {{详细描述}} 

*(如果有更多公司，重复上面的格式)* 

## 🏆 项目与重点业绩 
*(如果是技术人员写项目；如果是销售写大客户案例；如果是应届生写校园活动)* 

### 🔹 {{项目/案例名称}} 
*{{项目/案例一句话简介}}* 
- **扮演角色**: {{如：项目负责人 / 核心执行者}} 
- **背景/挑战**: {{简述面临的问题}} 
- **我的行动**: 
  - {{具体动作 1}} 
  - {{具体动作 2}} 
- **最终结果**: {{量化的结果}} 

## 🎓 教育经历 
- **{{学校名称}}** | {{专业}} | {{学历}} | *{{时间段}}* 

--- 
*Generated by AI Resume Assistant* 

# Input Data 
简历内容见附件。`
